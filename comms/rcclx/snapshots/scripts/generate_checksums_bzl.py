#!/usr/bin/env python3
# pyre-strict
"""
Script to generate a .bzl file with checksums from metadata files.

This script reads metadata.txt files from the stable snapshots and generates
a checksums.bzl file that can be loaded by the BUCK file.
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Dict, Optional


def parse_metadata_file(metadata_path: Path) -> Optional[str]:
    """
    Parse a metadata.txt file and extract the SHA256 checksum.

    Args:
        metadata_path: Path to metadata.txt file

    Returns:
        SHA256 checksum string or None if not found
    """
    if not metadata_path.exists():
        return None

    with open(metadata_path, "r") as f:
        content = f.read()

    # Look for SHA256 checksum in the format:
    # Checksums:
    #   sha1: ...
    #   sha256: abc123...
    match = re.search(r"sha256:\s*([0-9a-f]{64})", content, re.IGNORECASE)
    if match:
        return match.group(1)

    return None


def get_checksums_from_metadata(snapshots_root: Path) -> Dict[str, Dict[str, str]]:
    """
    Get checksums for all ROCm versions from their metadata files.

    Args:
        snapshots_root: Root path of the snapshots directory

    Returns:
        Dictionary with 'stable' and 'last_stable' keys, each containing
        a dictionary mapping ROCm version to SHA256 checksum
    """
    checksums: Dict[str, Dict[str, str]] = {
        "stable": {},
        "last_stable": {},
    }

    # Get stable checksums
    stable_dir = snapshots_root / "stable"
    if stable_dir.exists():
        for version_dir in stable_dir.iterdir():
            if not version_dir.is_dir():
                continue

            version = version_dir.name
            metadata_path = version_dir / "metadata.txt"

            checksum = parse_metadata_file(metadata_path)
            if checksum:
                checksums["stable"][version] = checksum
                print(f"Found stable checksum for ROCm {version}: {checksum}")
            else:
                print(f"Warning: No stable checksum found for ROCm {version}")

    # Get last-stable checksums
    last_stable_dir = snapshots_root / "last-stable"
    if last_stable_dir.exists():
        for version_dir in last_stable_dir.iterdir():
            if not version_dir.is_dir():
                continue

            version = version_dir.name
            metadata_path = version_dir / "metadata.txt"

            checksum = parse_metadata_file(metadata_path)
            if checksum:
                checksums["last_stable"][version] = checksum
                print(f"Found last-stable checksum for ROCm {version}: {checksum}")
            else:
                print(f"Warning: No last-stable checksum found for ROCm {version}")

    return checksums


def generate_bzl_file(output_path: Path, checksums: Dict[str, Dict[str, str]]) -> None:
    """
    Generate a .bzl file with checksum definitions.

    Args:
        output_path: Path where the .bzl file should be created
        checksums: Dictionary with 'stable' and 'last_stable' keys
    """
    # Create the .bzl file content
    lines = [
        "# AUTO-GENERATED FILE - DO NOT EDIT MANUALLY",
        "# This file is generated by generate_checksums_bzl.py",
        "# It contains SHA256 checksums for rcclx stable and last-stable artifacts in Manifold",
        "",
        "# SHA256 checksums for stable artifacts",
        "RCCLX_STABLE_CHECKSUMS = {",
    ]

    # Add stable checksums
    for version in sorted(checksums["stable"].keys()):
        checksum = checksums["stable"][version]
        lines.append(f'    "{version}": "{checksum}",')

    lines.append("}")
    lines.append("")

    # Add last-stable checksums
    lines.append("# SHA256 checksums for last-stable artifacts")
    lines.append("RCCLX_LAST_STABLE_CHECKSUMS = {")

    for version in sorted(checksums["last_stable"].keys()):
        checksum = checksums["last_stable"][version]
        lines.append(f'    "{version}": "{checksum}",')

    lines.append("}")
    lines.append("")

    # Write to file
    with open(output_path, "w") as f:
        f.write("\n".join(lines))

    total_checksums = len(checksums["stable"]) + len(checksums["last_stable"])
    print(
        f"\nGenerated {output_path} with {total_checksums} checksums "
        f"(stable: {len(checksums['stable'])}, last-stable: {len(checksums['last_stable'])})"
    )


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate .bzl file with checksums from metadata files"
    )
    parser.add_argument(
        "--snapshots-root",
        type=Path,
        required=True,
        help="Root path of the snapshots directory",
    )
    parser.add_argument(
        "--output",
        type=Path,
        required=True,
        help="Path where the .bzl file should be created",
    )

    args = parser.parse_args()

    # Validate inputs
    if not args.snapshots_root.exists():
        print(f"Error: Snapshots directory not found: {args.snapshots_root}")
        return 1

    print(f"Reading checksums from {args.snapshots_root}/stable/*/metadata.txt")
    checksums = get_checksums_from_metadata(args.snapshots_root)

    if not checksums:
        print("Warning: No checksums found in metadata files")
        print("Generating empty checksums file")

    generate_bzl_file(args.output, checksums)

    return 0


if __name__ == "__main__":
    sys.exit(main())
